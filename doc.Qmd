---
title: "Progetto DA"
format: html
#format: pdf
editor: visual
date: "`r Sys.Date()`"
---

```{r setup, include=FALSE}
library(knitr)
library(yaml)
library(moments)
library(ggplot2)
library(ggcorrplot)
library(MASS)
knitr::opts_chunk$set(echo = TRUE)
```

## Progetto di Data Analytics

L'analisi che si vuole effettuare concerne un dataset che descrive dati riguardanti l'inquinamento dell'aria (pollution) e il tasso di mortalità in 60 aree metropolitane negli Stati Uniti d'America nell'anno 1960.

Il dataset deriva da una rivista trimestrale di Statistica per le Scienze Fisiche, Chimiche e Ingegneristiche che viene pubblicata dall'*American Society for Quality* e dall'*American Statistical Association*, denominata *Technometrics*.

Più precisamente nel vol. 15 (463-482), in un articolo intitolato "*Instabilities of regression estimates relating air pollution to mortality*" che ha come autori McDonald G.C. and Schwing R.C. nel 1973.

L'obiettivo della presente analisi vuoleè quello di sviscerare le relazioni che sono presenti tra le variabili ambientali e la variabile target del tasso di mortalità per concludere con lo sviluppo di un modello predittivo per la variabile output (mort).

### Descrizione delle variabili presenti

Le variabili all'interno del dataset proposto sono 16

-   PREC ➜ Precipitazioni medie annue in pollici

-   JANT ➜ Temperatura media di gennaio in gradi F

-   JULT ➜ Temperatura media di luglio in gradi F

-   OVR65 ➜ % della popolazione SMSA (standard metropolitan statistical area) del 1960 di età pari o superiore a 65 anni

-   POPN ➜ Dimensione media della famiglia

-   EDUC ➜ Anni scolastici medi completati da coloro che hanno più di 22 anni

-   HOUS ➜ % di unità abitative integre e dotate di tutti i servizi

-   DENS ➜ Popolazione per miglio quadrato nelle aree urbanizzate, 1960

-   NONW ➜ % popolazione non bianca nelle aree urbanizzate, 1960

-   WWDRK ➜ % occupati nelle professioni dei colletti bianchi

-   POOR ➜ % di famiglie con reddito \< \$ 3000

-   HC ➜ Potenziale di inquinamento relativo da idrocarburi

-   NOX ➜ Potenziale di inquinamento relativo agli ossidi di azoto

-   SO2 ➜ Potenziale di inquinamento relativo all'anidride solforosa

-   HUMID ➜ Umidità relativa media annua % alle ore 13:00

-   MORT ➜ Tasso di mortalità totale corretto per età per 100.000 (abitanti)

## Importazione dei dati

```{r}
Pollution = read.csv("Pollution/pollution.csv")
```

## ANALISI DEL DATASET "Pollution"

```{r}
PollutionUnivConf <- read_yaml("pollution-univ.config.yaml")
```

```{r, results='asis'}
univarAnalysis <- function(conf, df) {
  cat("\n\n\\clearpage\n\\newpage")
  cat("\n\n##", conf$colname, "\n")
  if ("uselog" %in% conf$run) {
    df[, conf$colname] <- log(df[, conf$colname])
  }
  cat("\n\n Numero di NA: ", sum(is.na(df[, conf$colname]), na.rm = T), "\n\n")
  if ("filterzeros" %in% conf$run) {
    cat("\n\n Numero di zeri rimossi: ", sum(df[, conf$colname] == 0, na.rm = T), "\n\n")
    df <- df[df[, conf$colname] != 0,]
  }
  if (sum(
      as.logical("dobarplot" %in% conf$run), 
      as.logical("doboxplot" %in% conf$run),
      as.logical("dohist" %in% conf$run),
      as.logical("dodensity" %in% conf$run),
      as.logical("doqqplot" %in% conf$run)
    ) > 2) {
    par(mfrow = c(2, 2))
  } else {
    par(mfrow = c(1, 1))
  }
  if ("dotable" %in% conf$run) {
    print(kable(t(rbind(
      idx = levels(factor(df[, conf$colname])),
      abs = table(df[, conf$colname]),
      rel = prop.table(table(df[, conf$colname]))
    )), col.names = c("Level", "Abs. Freq", "Rel. Freq"), row.names = FALSE))
  } else {
    temp <- as.array(summary(df[, conf$colname]))
    temp["Skewness"] <- skewness(df[, conf$colname])
    if ("kurtosis" %in% conf$run) {
      temp["Kurtosis"] <- kurtosis(df[, conf$colname])
    }
    print(kable(as.array(temp), col.names = c("Stat", "Value")))
  }
  if ("dobarplot" %in% conf$run) {  
    barplot(table(df[, conf$colname]), main=NULL)
  }
  if ("doboxplot" %in% conf$run) {
    boxplot(df[, conf$colname], main=NULL)
  }
  if ("dohist" %in% conf$run) {
    hist(df[, conf$colname], freq = F, main=NULL, xlab = NULL)
  }
  if ("dodensity" %in% conf$run) {
    plot(density(df[, conf$colname], na.rm = T), main="")
  }
  if ("doqqplot" %in% conf$run) {
    qqnorm(df[, conf$colname])
    qqline(df[, conf$colname])
  }
  if (!is.na(conf$desc)) {
    cat("\n\n", conf$desc, "\n")
  }
}

out <- sapply(PollutionUnivConf$variables, univarAnalysis, df = Pollution)
```

## ANALISI BIVARIATA DEL DATASET

```{r}
PollutionBivConf <- read_yaml("pollution-biv.config.yaml")
```

```{r, results='asis'}
bivarAnalysis <- function(conf, df) {
  cat("\\newpage")
  cat("\n\n##", conf$colname, "\n")
  par(mfrow = c(1, 1))
  if ("uselog" %in% conf$run) {
    df[, conf$colname] <- log(df[, conf$colname])
  }
  cat("\n\n Numero di NA: ", sum(is.na(df[, conf$colname]), na.rm = T), "\n\n")
  if ("filterzeros" %in% conf$run) {
    cat("\n\n Numero di zeri rimossi: ", sum(df[, conf$colname] == 0, na.rm = T), "\n\n")
    df <- df[df[, conf$colname] != 0,]
  }
  if ("docmpboxplot" %in% conf$run) {
    boxplot(df[, conf$tgcol]~df[, conf$colname], 
            xlab = conf$colname, ylab = conf$tgcol)
  }
  if ("doanova" %in% conf$run) {
    anova_obj <- aov(df[, conf$tgcol]~df[, conf$colname])
    print(kable(summary(anova_obj)[1][[1]], row.names = FALSE))
    if ("doetasq" %in% conf$run) {
      etasq_obj <- summary(anova_obj)[1][[1]][[2]][1]/(summary(anova_obj)[1][[1]][[2]][2]+
                                                         summary(anova_obj)[1][[1]][[2]][1])
      cat("\n\n Eta squared: ", etasq_obj, "\n\n")
    }
  }
  if ("doscatterplot" %in% conf$run) {
    plot(df[, conf$colname], df[, conf$tgcol], xlab = conf$colname, 
         ylab = conf$tgcol)
    lm_obj <- lm(df[, conf$tgcol]~df[, conf$colname])
    abline(a= lm_obj$coefficients[1], b = lm_obj$coefficients[2], col=2)
    par(mfrow = c(2, 2))
    plot(lm_obj, which = c(1,2,4,5))
    print(kable(summary(lm_obj)$coefficients, row.names = FALSE))
    if ("dorsq" %in% conf$run) {
      print(kable(cbind(
        cov = cov(df[, conf$colname], df[, conf$tgcol], use = "complete.obs"),
        cor = cor(df[, conf$colname], df[, conf$tgcol], use = "complete.obs"),
        rsq = summary(lm_obj)$r.squared
      )))
    }
  }
  if (!is.na(conf$desc)) {
    cat("\n\n", conf$desc, "\n")
  }
}

out <- sapply(PollutionBivConf$variables, bivarAnalysis, df = Pollution)
```

### Considerazioni

Le varie analisi bivariate per le singole variabili evidenziano come ci sia un dato che risulta sempre anomalo (in 12 variabili su 16) quando viene valutata la Cook's Distance. Questo è l'osservazione 37. Si decide dunque di procedere effettuando un ricalcolo dei valori degli indici $R^2$-Adjusted e p-value delle singole variabili, utilizzando il medesimo dataset epurato però della suddetta rilevazione.

```{r}
senza37 <- Pollution[-37, ]


bivarAnalysisLight <- function(conf, df) {
  cat("\n\n##", conf$colname, "\n")
  
  if ("uselog" %in% conf$run) {
    df[, conf$colname] <- log(df[, conf$colname])
  }
 
  if ("doscatterplot" %in% conf$run) {
    lm_obj <- lm(df[, conf$tgcol]~df[, conf$colname])
    print(kable(summary(lm_obj)$coefficients, row.names = FALSE))
    if ("dorsq" %in% conf$run) {
      print(kable(cbind(
        cov = cov(df[, conf$colname], df[, conf$tgcol], use = "complete.obs"),
        cor = cor(df[, conf$colname], df[, conf$tgcol], use = "complete.obs"),
        rsq = summary(lm_obj)$r.squared
      )))
    }
  }

}


out <- sapply(PollutionBivConf$variables, bivarAnalysisLight, df = senza37)
```

# ANALISI MULTIVARIATA: stima del modello

In primis, per procedere con l'analisi multivariata, si va a valutare la correlazione tra le varie variabili per diagnosticare eventualmente casi di ridondanza.

```{r}
ggcorrplot(cor(Pollution), hc.order = TRUE,  type = "lower", lab = F)
```

Poichè nell'analisi bivariata sono stati considerati i logaritmi delle variabili *nox*, *so2* e *hc,* si riesegue la matrice di correlazione con le variabili in scala logaritmica:

```{r}
datasetlog <- Pollution
datasetlog$hc <- log(datasetlog$hc)
datasetlog$nox <- log(datasetlog$nox)
datasetlog$so2 <- log(datasetlog$so2)

ggcorrplot(cor(datasetlog), hc.order = TRUE,  type = "lower", lab = F)
```

Si può evidenziare come la correlazione delle tre suddette variabili, specialmente con la variabile mort, sia aumentata decisamente, con un futuro impatto anche nell'aumento del valore dell'indice Adjusted-$R^2$

Si nota anche come l'elevata correlazione tra le variabili *hc* e *nox* implichino ridondanza e dipendenza lineare. Si preferisce dunque scegliere di mantenere una sola delle due variabili, ovvero *nox*.

### Modello StepAIC

Si procede ora con formulare un primo abbozzo del modello di regressione multivariata tramite StepAIC, in maniera tale da avere un metro di paragone anche se con un modello costruito algoritmicamente.

```{r}
lreg <- lm(mort ~ ., data = Pollution)
a <- stepAIC(lreg, direction = "both")
```

```{r}
summary(a)
```

L'indice $R^2$ del modello è pari a 71.39%

L'AIC risultante è di 429.63, con variabili considerate finali $$\text{mort} = \text{prec} + \text{jant} + \text{jult} + \text{ovr65} + \text{popn} + \text{educ} + \text{nonw} + \text{hc} + \text{nox}$$

### Primo modello

Considerando le variabili *prec*, *popn*, *educ*, *hous*, *nonw*, *poor, log(so2)* e *log(nox)*, che, dall'analisi bivariata sono quelle che sembrano essere più correlate alla variabile *mort*, creiamo il nostro primo modelllo.

```{r}
mod1 <- lm(mort ~ prec + popn + educ + hous + nonw + log(so2) + poor + log(nox), data = Pollution)
summary(mod1)
AIC(mod1)                        
```

Si nota che questo modello ha un Adjusted R-squared di 67.41% e l'AIC di 608.9.

Andando a vedere i p-value, si vede che quello delle variabili *popn* e *log(so2)* è molto alto e si decide quindi di toglierle dal modello.

Ed inoltre aggiungiamo wwdrk\*educ, in quanto sono abbastanza correlate tra di loro.

```{r}
mod2 <- lm(mort ~ prec + educ + hous + nonw + poor + log(nox) + wwdrk*educ, data = Pollution)
summary(mod2)
AIC(mod2)
```

In questo modo l'Adjusted R-squared è arrivato a 0.6825 e l'AIC a 607.333

Ma notiamo che probabilmente wwdrk\*educ non aggiunge molto al nostro modello, quindi lo togliamo.

Sempre guardando la correlazione, proviamo ad aggiungere $\text{hous}*\text{educ}$, $\text{poor}*\text{nonw}$ , $\text{poor}*\text{hous}$ e $\text{ovr65}*\text{nonw}$ che sono quelli con più correlazione

```{r}
mod3 <- lm(mort ~ prec + educ + hous + nonw + poor + log(nox) + hous*educ + poor*nonw + poor*hous + ovr65*nonw, data = Pollution)
summary(mod3)
AIC(mod3)
```

Ma guardando ai p-value, vediamo che $\text{educ}*\text{hous}$ va bene, $\text{poor}*\text{nonw}$ va bene ma può essere migliorato, mentre $\text{poor}*\text{hous}$ e $\text{ovr65}*\text{nonw}$ possono essere eliminati tranquillamente.

Per migliorare $\text{poor}*\text{nonw}$ proviamo ad aggiungere la variabile $\text{educ}$ , in quanto ha senso considerarle assieme

```{r}
mod4 <- lm(mort ~ prec + educ + hous + nonw + poor + log(nox) + hous*educ + poor*nonw*educ, data = Pollution)
summary(mod4)
AIC(mod4)
```

Otteniamo così un modello con l'Adjusted R-squared di 80.98% e l'AIC di 578.9574

$$ mort = prec + log(nox) + educ*hous + educ*nonw*poor $$

#### Primo modello senza osservazione 37

Abbiamo visto però dall'analisi bivariata senza l'osservazione 37 che la variabile *so2* dovrebbe essere di fondamentale importanza per contributo al modello ma nel fit appena presentato è stata scartata al primo step.

Proviamo dunque a vedere se, considerando il nuovo dataset *senza37* e l'ultimo modello fittante proposto, la suddetta variabile ci porta dei valori migliori in termini di $R^2$-adjusted ed AIC.

```{r}
mod5 <- lm(mort ~ prec + educ + hous + nonw + poor + log(so2)+ log(nox) + hous*educ + poor*nonw*educ, data = senza37)
summary(mod5)
AIC(mod5)
```

Si vede che il valore dell'indice $R^2$-adjusted (80.01) è rimasto pressochè invariato, mentre è sceso abbastanza il modulo dell'AIC che risulta ora essere pari a 565.76, e dunque migliore.

### Secondo modello

Facendo alcune considerazioni aggiuntive però, si suppone che l'inquinamento dei gas nell'atmosfera provochi ad esempio piogge acide, evento atmosferisco che essendo dannoso per l'organismo, potrebbe comportare un aumento della mortalità.

Infatti si va a valutare anche la combinazione delle variabili $\text{prec}*\log(\text{nox})*\log(\text{so2})$

```{r}
regmulti1 <- lm(mort ~ educ + nonw + poor + prec*log(nox)*log(so2) + educ*poor*nonw + hous*educ  , data = Pollution)
summary(regmulti1)

AIC(regmulti1)

```

Questo modello ha un indice $R^2=81,19\%$ che è sicuramente sufficientemente elevato per poter essere considerato un buon modello. L'AIC corrispondente è di 581.7, che è un valore comunque accettabile.

Nonostante si possa reputare una buona supposizione, il modello non sembra confermarla, o meglio, sembra essercene uno migliore, che è quello visto in precedenza.

Si prova ora a cambiare il dataset utilizzando quello senza l'osservazione numero 37, mantenendo però il modello appena creato:

```{r}
regmulti2 <- lm(mort ~ educ + nonw + poor + prec*log(nox)*log(so2) + educ*poor*nonw + hous*educ  , data = senza37)
summary(regmulti2)

AIC(regmulti2)

```

Seppur il valore dell'AIC scenda (571.2), il modulo di $R^2$ diminuisce (79.01%). Sembra dunque che il modello sia "*peggiorato*".

Si applica dunque la funzione stepAIC al modello *regmulti2* appena formulato, per vedere se in realtà ne è ancora migliorabile la stima

```{r}
regmultiAIC <- stepAIC(regmulti2)
summary(regmultiAIC)
AIC(regmultiAIC)
```

È aumentato leggermente l' $R^2$ che ora risulta essere pari all'80.65% e l'AIC è sceso a 562.3, che è un valore leggermente migliore rispetto a quello ottenuto con il modello *mod5* .
