---
title: "Progetto DA"
format: html
#format: pdf
editor: visual
date: "`r Sys.Date()`"
---

```{r setup, include=FALSE}
library(knitr)
library(yaml)
library(moments)
library(ggplot2)
library(ggcorrplot)
library(MASS)
knitr::opts_chunk$set(echo = TRUE)
```

## Progetto di Data Analytics

Con la presente analisi si vuole sviluppare un modello predittivo per la variabile mort.

### Descrizione delle variabili presenti

Le variabili all'interno del dataset proposto sono 16

-   PREC ➜ Precipitazioni medie annue in pollici

-   JANT ➜ Temperatura media di gennaio in gradi F

-   JULT ➜ Temperatura media di luglio in gradi F

-   OVR65 ➜ % della popolazione SMSA (standard metropolitan statistical area) del 1960 di età pari o superiore a 65 anni

-   POPN ➜ Dimensione media della famiglia

-   EDUC ➜ Anni scolastici medi completati da coloro che hanno più di 22 anni

-   HOUS ➜ % di unità abitative integre e dotate di tutti i servizi

-   DENS ➜ Popolazione per miglio quadrato nelle aree urbanizzate, 1960

-   NONW ➜ % popolazione non bianca nelle aree urbanizzate, 1960

-   WWDRK ➜ % occupati nelle professioni dei colletti bianchi

-   POOR ➜ % di famiglie con reddito \< \$ 3000

-   HC ➜ Potenziale di inquinamento relativo da idrocarburi

-   NOX ➜ Potenziale di inquinamento relativo agli ossidi di azoto

-   SO2 ➜ Potenziale di inquinamento relativo all'anidride solforosa

-   HUMID ➜ Umidità relativa media annua % alle ore 13:00

-   MORT ➜ Tasso di mortalità totale corretto per età per 100.000 (abitanti)

## Importazione dei dati

```{r}
Pollution = read.csv("Pollution/pollution.csv")
```

## ANALISI DEL DATASET "Pollution"

```{r}
PollutionUnivConf <- read_yaml("pollution-univ.config.yaml")
```

```{r, results='asis'}
univarAnalysis <- function(conf, df) {
  cat("\n\n\\clearpage\n\\newpage")
  cat("\n\n##", conf$colname, "\n")
  if ("uselog" %in% conf$run) {
    df[, conf$colname] <- log(df[, conf$colname])
  }
  cat("\n\n Numero di NA: ", sum(is.na(df[, conf$colname]), na.rm = T), "\n\n")
  if ("filterzeros" %in% conf$run) {
    cat("\n\n Numero di zeri rimossi: ", sum(df[, conf$colname] == 0, na.rm = T), "\n\n")
    df <- df[df[, conf$colname] != 0,]
  }
  if (sum(
      as.logical("dobarplot" %in% conf$run), 
      as.logical("doboxplot" %in% conf$run),
      as.logical("dohist" %in% conf$run),
      as.logical("dodensity" %in% conf$run),
      as.logical("doqqplot" %in% conf$run)
    ) > 2) {
    par(mfrow = c(2, 2))
  } else {
    par(mfrow = c(1, 1))
  }
  if ("dotable" %in% conf$run) {
    print(kable(t(rbind(
      idx = levels(factor(df[, conf$colname])),
      abs = table(df[, conf$colname]),
      rel = prop.table(table(df[, conf$colname]))
    )), col.names = c("Level", "Abs. Freq", "Rel. Freq"), row.names = FALSE))
  } else {
    temp <- as.array(summary(df[, conf$colname]))
    temp["Skewness"] <- skewness(df[, conf$colname])
    if ("kurtosis" %in% conf$run) {
      temp["Kurtosis"] <- kurtosis(df[, conf$colname])
    }
    print(kable(as.array(temp), col.names = c("Stat", "Value")))
  }
  if ("dobarplot" %in% conf$run) {  
    barplot(table(df[, conf$colname]), main=NULL)
  }
  if ("doboxplot" %in% conf$run) {
    boxplot(df[, conf$colname], main=NULL)
  }
  if ("dohist" %in% conf$run) {
    hist(df[, conf$colname], freq = F, main=NULL, xlab = NULL)
  }
  if ("dodensity" %in% conf$run) {
    plot(density(df[, conf$colname], na.rm = T), main="")
  }
  if ("doqqplot" %in% conf$run) {
    qqnorm(df[, conf$colname])
    qqline(df[, conf$colname])
  }
  if (!is.na(conf$desc)) {
    cat("\n\n", conf$desc, "\n")
  }
}

out <- sapply(PollutionUnivConf$variables, univarAnalysis, df = Pollution)
```

## ANALISI BIVARIATA DEL DATASET

```{r}
PollutionBivConf <- read_yaml("pollution-biv.config.yaml")
```

```{r, results='asis'}
bivarAnalysis <- function(conf, df) {
  cat("\\newpage")
  cat("\n\n##", conf$colname, "\n")
  par(mfrow = c(1, 1))
  if ("uselog" %in% conf$run) {
    df[, conf$colname] <- log(df[, conf$colname])
  }
  cat("\n\n Numero di NA: ", sum(is.na(df[, conf$colname]), na.rm = T), "\n\n")
  if ("filterzeros" %in% conf$run) {
    cat("\n\n Numero di zeri rimossi: ", sum(df[, conf$colname] == 0, na.rm = T), "\n\n")
    df <- df[df[, conf$colname] != 0,]
  }
  if ("docmpboxplot" %in% conf$run) {
    boxplot(df[, conf$tgcol]~df[, conf$colname], 
            xlab = conf$colname, ylab = conf$tgcol)
  }
  if ("doanova" %in% conf$run) {
    anova_obj <- aov(df[, conf$tgcol]~df[, conf$colname])
    print(kable(summary(anova_obj)[1][[1]], row.names = FALSE))
    if ("doetasq" %in% conf$run) {
      etasq_obj <- summary(anova_obj)[1][[1]][[2]][1]/(summary(anova_obj)[1][[1]][[2]][2]+
                                                         summary(anova_obj)[1][[1]][[2]][1])
      cat("\n\n Eta squared: ", etasq_obj, "\n\n")
    }
  }
  if ("doscatterplot" %in% conf$run) {
    plot(df[, conf$colname], df[, conf$tgcol], xlab = conf$colname, 
         ylab = conf$tgcol)
    lm_obj <- lm(df[, conf$tgcol]~df[, conf$colname])
    abline(a= lm_obj$coefficients[1], b = lm_obj$coefficients[2], col=2)
    par(mfrow = c(2, 2))
    plot(lm_obj, which = c(1,2,4,5))
    print(kable(summary(lm_obj)$coefficients, row.names = FALSE))
    if ("dorsq" %in% conf$run) {
      print(kable(cbind(
        cov = cov(df[, conf$colname], df[, conf$tgcol], use = "complete.obs"),
        cor = cor(df[, conf$colname], df[, conf$tgcol], use = "complete.obs"),
        rsq = summary(lm_obj)$r.squared
      )))
    }
  }
  if (!is.na(conf$desc)) {
    cat("\n\n", conf$desc, "\n")
  }
}

out <- sapply(PollutionBivConf$variables, bivarAnalysis, df = Pollution)
```

# ANALISI MULTIVARIATA: stima del modello

In primis, per procedere con l'analisi multivariata, si va a valutare la correlazione tra le varie variabili per diagnosticare eventualmente casi di ridondanza.

```{r}
ggcorrplot(cor(Pollution), hc.order = TRUE,  type = "lower", lab = F)
```

Facendo alcune considerazioni preliminari, si suppone che l'inquinamento dei gas nell'atmosfera che provocano ad esempio piogge acide risultino dannose per l'organismo con un consequenziale risolvo di un aumento della mortalità.

Si decide di procedere dunque con l'applicazione del logaritmo alle singole varibili nox, so2 e hc

```{r}
datasetlog <- Pollution
datasetlog$hc <- log(datasetlog$hc)
datasetlog$nox <- log(datasetlog$nox)
datasetlog$so2 <- log(datasetlog$so2)

ggcorrplot(cor(datasetlog), hc.order = TRUE,  type = "lower", lab = F)
```

Si può evidenziare come la correlazione delle tre suddette variabili, specialmente con la variabile mort, sia aumentata decisamente, con un futuro impatto anche nell'aumento del valore dell'indice Adjusted-$R^2$

Si nota anche come l'elevata correlazione tra le variabili hc e nox implichino ridondanza e dipendenza lineare. Si preferisce dunque scegliere di mantenere una sola delle due variabili, ovvero nox.

Si procede ora con formulare un primo abbozzo del modello di regressione multivariata tramite StepAIC, in maniera tale da avere un metro di paragone anche se con un modello costruito algoritmicamente.

```{r}
lreg <- lm(mort ~ ., data = Pollution)
a <- stepAIC(lreg, direction = "both")
```

```{r}
summary(a)
```

L'AIC risultante dal modello sviluppato dalla funzione stepAIC è 429.63 con variabili considerate finali $$\text{mort} \sim \text{prec} + \text{jant} + \text{jult} + \text{ovr65} + \text{popn} + \text{educ} + \text{nonw} + \text{hc} + \text{nox}$$

Considerando le variabili prec, popn, educ, hous, nonw, poor e so2, che, dall'analisi bivariata sono quelle che sembrano essere più correlate alla variabile mort, creiamo il nostro primo modelllo.

```{r}
mod1 <- lm(mort ~ prec + popn + educ + hous + nonw + poor + so2, data = Pollution)
summary(mod1)
AIC(mod1)
```

Si nota che questo modello ha un Adjusted R-squared di 0.6656 e l'AIC di 609.6126

Andando a vedere i p-value, si vede che quello della variabile popn è molto alto e si decide quindi di togliere questa variabile dal modello.

Guardando alla correlazione delle variabili, scegliamo di sostituire so2 con log(nox).

Ed inoltre aggiungiamo wwdrk\*educ, in quanto sono abbastanza correlate tra di loro.

```{r}
mod2 <- lm(mort ~ prec + educ + hous + nonw + poor + log(nox) + wwdrk*educ, data = Pollution)
summary(mod2)
AIC(mod2)
```

In questo modo l'Adjusted R-squared è arrivato a 0.6825 e l'AIC a 607.333

Ma notiamo che probabilmente wwdrk\*educ non aggiunge molto al nostro modello, quindi lo togliamo.

Sempre guardando la correlazione, proviamo ad aggiungere hous\**educ, poor*\*nonw e poor\*hous e ovr65 \* nonw, che sono quelli con più correlazione

```{r}
mod3 <- lm(mort ~ prec + educ + hous + nonw + poor + log(nox) + hous*educ + poor*nonw + poor*hous + ovr65*nonw, data = Pollution)
summary(mod3)
AIC(mod3)
```

Ma guardando ai p-value, vediamo che educ\*hous va bene, nonw \* poor va bene ma può essere migliorato, mentre poor \* hous e ovr65\*nonw possono essere eliminati tranquillamente

Per migliorare nonw\*poor proviamo ad aggiungere la variabile educ, in quanto ha senso considerarle assieme

```{r}
mod4 <- lm(mort ~ prec + educ + hous + nonw + poor + log(nox) + hous*educ + poor*nonw*educ, data = Pollution)
summary(mod4)
AIC(mod4)
```

Otteniamo così un modello con l'Adjusted R-squared di 0.8098 e l'AIC di 578.9574

Il modello da noi formulato è invece il seguente

```{r}
regmulti1 <- lm(mort ~ educ + nonw + poor + prec*log(nox) + educ*poor*nonw + hous*educ  , data = Pollution)
summary(regmulti1)

AIC(regmulti1)


```

Questo modello ha un indice $R^2=80,62\%$ che è sicuramente sufficientemente elevato per poter essere considerato un buon modello. L'AIC corrispondente è di 580.8, che è un valore accettabile e inferiore rispetto a ciò che si era ottenuto con il modello formulato tramite la funzione stepAIC originariamente.

Si prova dunque ora a riapplicare la funzione stepAIC al modello *regmulti1* appena formulato, per vedere se ne è ancora migliorabile la stima

```{r}
regmultiAIC <- stepAIC(regmulti1)
summary(regmultiAIC)
AIC(regmultiAIC)
```

\'E aumentato leggermente l' $R^2$ che ora risulta essere pari all'80,98% e l'AIC è sceso a 578,96, che è un valore migliore rispetto a quello ottenuto con il modello *regmulti1*.

Un altro modello che restituisce i medesimi parametri appena citati è questo sottostante, che sembra essere un buon compromesso tra bontà del fit e complessità del modello derivante dal numero di variabili e dal loro prodotto.

```{r}

test2 <- lm(mort ~ prec + log(nox) + educ*hous + educ*nonw*poor, data = Pollution)
summary(test2)
AIC(test2)

```
